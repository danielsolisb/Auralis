{% extends 'main/dashboard.html' %}
{% load static %}

{% block fixedbar %}
{# Este bloque ahora est√° vac√≠o, como solicitaste #}
{% endblock %}

{% block content %}
<!--Page content-->
<div id="page-content">
  <div class="row">
    <div class="col-lg-12">
      <div class="panel monitor-panel">

        <!-- BARRA SUPERIOR HORIZONTAL -->
        <div class="panel-heading compact">
          <div class="monitor-toolbar">
            <h3 class="panel-title" id="chart-panel-title">Monitor en Tiempo Real</h3>


<div class="toolbar-group station">
  <label class="toolbar-label">ESTACI√ìN</label>
  <!-- Select + bot√≥n en l√≠nea -->
  <div class="station-input">
    <select id="station-selector" class="form-control form-control-sm">
      <option value="">Seleccione una estaci√≥n...</option>
      {% for station in stations %}
        <option value="{{ station.id }}">{{ station.name }}</option>
      {% endfor %}
    </select>

    <button type="button" id="load-sensors-btn" class="btn btn-primary btn-sm">
      Consultar
    </button>
  </div>
</div>

            <div class="toolbar-group">
              <div class="range-chips" id="range-chips">
                <button class="chip active" data-range="5m">5 min</button>
                <button class="chip" data-range="30m">30 min</button>
                <button class="chip" data-range="1h">1 h</button>
                <button class="chip" data-range="3h">3 h</button>
              </div>
              <span id="live-indicator" class="live-indicator on">En vivo</span>
              <button id="back-to-live" class="btn btn-link btn-xs" style="display:none;">Volver al vivo</button>
            </div>
          </div>
        </div>

        <!-- CONTENIDO -->
        <div class="panel-body monitor-flex">
          <!-- IZQUIERDA: gr√°fico -->
          <div class="chart-wrap">
            <div id="unified-chart"></div>
          </div>

          <!-- DERECHA: SOLO valores en vivo -->
          <aside class="side-wrap">
            <div class="panel values-panel">
              
              <div class="panel-body" id="values-panel"></div>
            </div>
          </aside>
        </div>

      </div>
    </div>
  </div>
</div>

<style>
  /* ===== Layout compacto ===== */
  .monitor-panel .panel-heading.compact{ padding:5px 7px; }
  .monitor-toolbar{
    position:relative; z-index:3;  /* asegura clics por encima de cualquier canvas */
    display:flex; align-items:center; gap:12px; flex-wrap:wrap;
  }
  .monitor-toolbar .panel-title{ margin:0 8px 0 0; font-size:16px; font-weight:600; }
  .toolbar-group{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .toolbar-label{ margin:0; font-size:12px; text-transform:uppercase; color:#6c757d; }

  .monitor-flex{ display:flex; gap:12px; align-items:stretch; }
  .chart-wrap{ flex:1 1 auto; min-width:0; }
  #unified-chart{ width:100%; height:78vh; }

  .side-wrap{ width:280px; flex:0 0 280px; display:flex; flex-direction:column; max-height:78vh; }
  .values-panel{ flex:1 1 auto; overflow:auto; margin-bottom:0; }

  /* Tarjetas de valores */
  #values-panel .live-card{
    border:1px solid #e9ecef; border-radius:10px; padding:10px 12px; margin-bottom:10px;
    display:flex; justify-content:space-between; align-items:baseline; background:#fff;
  }
  #values-panel .live-card .name{ font-weight:600; }
  #values-panel .live-card .val{ font-size:1.35em; font-weight:300; }
  #values-panel .live-card .unit{ color:#6c757d; font-size:.9em; margin-left:4px; }

  /* Chips */
  .range-chips{ display:flex; flex-wrap:wrap; gap:8px; }
  .range-chips .chip{
    border:1px solid #cfd4da; border-radius:999px; padding:6px 12px;
    background:#fff; font-size:12px; cursor:pointer;
  }
  .range-chips .chip.active{ background:#0d6efd; color:#fff; border-color:#0d6efd; }

  .live-indicator{ font-size:12px; color:#6c757d; }
  .live-indicator.on::before{
    content:''; display:inline-block; width:8px; height:8px; border-radius:50%; background:#28a745; margin-right:6px;
    box-shadow:0 0 0 2px rgba(40,167,69,.15);
  }

  /* Responsive */
  @media (max-width: 992px){
    .monitor-flex{ flex-direction:column; }
    .side-wrap{ width:100%; flex-basis:auto; max-height:none; }
    #unified-chart{ height:60vh; }
  }
  @media (max-width: 576px){
    #unified-chart{ height:55vh; }
  }

  /* Mantener select + bot√≥n en la misma l√≠nea y que el bot√≥n NO ‚Äúsalte‚Äù hacia abajo */
.toolbar-group.station { flex-wrap: nowrap; }

.station-input{
  display: flex;
  align-items: center;
  gap: 8px;
  white-space: nowrap;          /* evita el salto del bot√≥n */
}

.station-input select{ min-width: 260px; }   /* ancho c√≥modo; ajusta si quieres */
#load-sensors-btn{ white-space: nowrap; }    /* el texto no se parte */

/* Un poco m√°s de aire debajo de la barra para que nunca ‚Äútoque‚Äù el chart */
.monitor-panel .panel-heading.compact{ padding-bottom: 12px; }

</style>
{% endblock %}



{% block script %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"></script>

<script>
$(function () {
  // ============================
  // ESTADO GLOBAL
  // ============================
  let mqttClient = null;
  let currentSubscriptions = [];
  let currentStationName = '';
  let currentStationId = null;

  let sensorMetadata = {};     // { id: {...} }
  let sensorIndexById = {};    // { id: idx }
  let seriesBuffers = {};      // { id: [ [Date, value], ... ] }
  let currentSensorIds = [];   // orden de render

  // Rango y vivo
  const RANGE_MS = { '5m': 5*60*1000, '30m': 30*60*1000, '1h': 60*60*1000, '3h': 3*60*60*1000 };
  let currentRange = '5m';     // por defecto
  let isLiveMode   = true;     // autoscroll activo
  
  let liveUpdateTimer = null;  // Temporizador para el modo "En Vivo"
  let topicToSensorIdMap = {};
  let lastMessageTime = {};      // Para rastrear el √∫ltimo mensaje de cada sensor
  // Para nearestValue del tooltip que ya tienes
  let activeAxisIndex = null;



// ------------------------------------
  
  
  // DOM
  const stationSelector  = $('#station-selector');
  const loadButton       = $('#load-sensors-btn');
  const valuesPanel      = $('#values-panel');
  const chipsWrap        = $('#range-chips');
  const liveIndicator    = $('#live-indicator');
  const backToLiveBtn    = $('#back-to-live');

  const chartDom         = document.getElementById('unified-chart');
  const unifiedChart     = echarts.init(chartDom);

  // ============================
  // MQTT
  // ============================
  //initMQTTClient();
  // ============================
    // MQTT (L√≥gica de conexi√≥n y suscripci√≥n modificada)
    // ============================
    stationSelector.on('change', () => loadButton.prop('disabled', !stationSelector.val()));
    loadButton.prop('disabled', !stationSelector.val());
    loadButton.on('click', () => {
        const stationId = stationSelector.val();
        if (stationId) fetchAndRenderUnifiedChart(stationId);
    });

   // La conexi√≥n ahora se inicia con los datos de la estaci√≥n
   // REEMPLAZA initMQTTClient CON ESTA FUNCI√ìN


function connectAndSubscribe(brokerIp, brokerPort, topics) {
  if (mqttClient) { try { mqttClient.disconnect(); } catch (e) {} }

  const HOST    = window.location.hostname;
  const PORT    = 443;
  const WS_PATH = "/mqtt";
  const USE_SSL = (location.protocol === 'https:');
  const clientId = "auralis_dashboard_" + Math.random().toString(16).slice(2, 10);

  const DEBUG_ALL = true;
  let retryMs = 1000, retryMax = 15000;

  mqttClient = new Paho.MQTT.Client(HOST, Number(PORT), WS_PATH, clientId);

  mqttClient.onConnectionLost = function (resp) {
    console.warn("MQTT conexi√≥n perdida:", (resp && resp.errorMessage) || resp);
    setTimeout(() => {
      console.log("Reintentando conexi√≥n MQTT...");
      mqttClient.connect(connectOpts);
      retryMs = Math.min(retryMs * 2, retryMax);
    }, retryMs);
  };

  mqttClient.onMessageArrived = function (m) {
    try { console.log("DEBUG msg:", m.destinationName, m.payloadString); } catch (_) {}
    try { onMessageArrived(m); } catch (e) { console.error("onMessageArrived error:", e); }
  };

  const connectOpts = {
    useSSL: USE_SSL,
    keepAliveInterval: 60,
    timeout: 8,
    cleanSession: true,
    onSuccess: () => {
      console.log(`MQTT conectado a wss://${HOST}:${PORT}${WS_PATH}`);
      retryMs = 1000;

      // No borramos mapa ni desuscribimos aqu√≠ (se hace antes, al cambiar estaci√≥n)
      // Suscripciones
      if (DEBUG_ALL) {
        try { mqttClient.subscribe('#', { qos: 0 }); console.log("DEBUG: suscrito a #"); } catch {}
      }
      topics.forEach(t => {
        try {
          mqttClient.subscribe(t, { qos: 0 });
          currentSubscriptions.push(t); // para poder desuscribir luego
          console.log("Suscrito:", t);
        } catch (e) {
          console.error("Error al suscribir", t, e);
        }
      });
    },
    onFailure: (e) => {
      console.error("MQTT connect failed:", (e && e.errorMessage) || e);
      setTimeout(() => {
        console.log("Reintentando conexi√≥n MQTT...");
        mqttClient.connect(connectOpts);
        retryMs = Math.min(retryMs * 2, retryMax);
      }, retryMs);
    }
  };

  console.log("Conectando MQTT por WSS v√≠a /mqtt ...");
  mqttClient.connect(connectOpts);
}




    function onConnectionLost(resp) {
        if (resp.errorCode !== 0) {
            console.log("Conexi√≥n MQTT perdida:", resp.errorMessage);
            // Se puede agregar un reintento si se desea
        }
    }

    function subscribeToTopic(topic) {
        if (mqttClient && mqttClient.isConnected()) {
            console.log(`Suscribiendo a: ${topic}`);
            mqttClient.subscribe(topic);
            currentSubscriptions.push(topic);
        }
    }

    function unsubscribeFromAllTopics() {
  if (mqttClient && mqttClient.isConnected() && currentSubscriptions.length > 0) {
    currentSubscriptions.forEach(t => {
      try { mqttClient.unsubscribe(t); } catch(e) {}
    });
    console.log("Se desuscribi√≥ de todos los topics anteriores.");
  }
  currentSubscriptions = [];
  // ‚ùå NO limpiar aqu√≠: topicToSensorIdMap = {};
}
   // ============================
    // CARGA ESTACI√ìN + HIST√ìRICO
    // ============================

// REEMPLAZA ESTA FUNCI√ìN
// REEMPLAZA ESTA FUNCI√ìN
function fetchAndRenderUnifiedChart(stationId) {
  unsubscribeFromAllTopics();
  stopLiveTimer();

  // Reset
  currentStationId = stationId;
  sensorMetadata = {}; sensorIndexById = {}; seriesBuffers = {};
  currentSensorIds = []; activeAxisIndex = null;
  lastMessageTime = {};
  topicToSensorIdMap = {};              // üîë limpiamos el mapa aqu√≠
  unifiedChart.clear(); valuesPanel.empty();
  isLiveMode = true;
  setLiveUI(true);

  $.getJSON(`/api/stations/${stationId}/sensors/`, function (response) {
    if (!response.sensors || response.sensors.length === 0) {
      valuesPanel.html('<p class="text-center">Esta estaci√≥n no tiene sensores activos.</p>');
      return;
    }

    currentStationName = response.station_name;
    $('#chart-panel-title').text(`Monitor en Tiempo Real - ${currentStationName}`);

    let topicsToSubscribe = [];
    currentSensorIds = response.sensors.map(s => s.id);

    response.sensors.forEach((s, i) => {
      sensorMetadata[s.id] = s;
      sensorIndexById[s.id] = i;
      seriesBuffers[s.id] = [];

      valuesPanel.append(
        `<div class="live-card" id="live-card-${s.id}">
           <span class="name">${s.name}</span>
           <span><span class="val" id="value-display-${s.id}">--</span>
           <span class="unit">${s.unit || ''}</span></span>
         </div>`
      );

      if (s.topic) {
        const t = String(s.topic).trim();

        // Suscribimos exactamente lo que devuelve la API
        topicsToSubscribe.push(t);

        // üîë Guardamos varias claves equivalentes para evitar misses
        topicToSensorIdMap[t] = s.id;
        if (t.endsWith('/')) topicToSensorIdMap[t.slice(0, -1)] = s.id;
        else                 topicToSensorIdMap[t + '/']        = s.id;
      } else {
        console.warn(`Sensor "${s.name}" (ID: ${s.id}) no tiene un topic MQTT configurado.`);
      }
    });

    const option = buildUnifiedChartOption(response.sensors);
    unifiedChart.setOption(option, true);

    unifiedChart.off('updateAxisPointer').on('updateAxisPointer', function (e) {
      if (e.axesInfo && e.axesInfo.length) activeAxisIndex = e.axesInfo[0].axisIndex;
    });
    unifiedChart.off('dataZoom').on('dataZoom', function(){
      const opt = unifiedChart.getOption();
      const dz = (opt.dataZoom && opt.dataZoom.length > 1) ? opt.dataZoom[1] : null;
      if (!dz) return;
      const atRight = (typeof dz.end === 'number') ? (dz.end > 99) : true;
      setLiveUI(atRight);
      isLiveMode = atRight;
    });

    const brokerIp   = response.station_ip   || '{{ mqtt_broker_ip }}';
    const brokerPort = response.station_port || {{ mqtt_broker_port }};
    if (topicsToSubscribe.length > 0) {
      connectAndSubscribe(brokerIp, brokerPort, topicsToSubscribe);
    }

    requestHistory(currentRange);
    initRangeChips();
    startLiveTimer();

    setTimeout(() => unifiedChart.resize(), 0);
    $(window).off('resize._auralis').on('resize._auralis', () => unifiedChart.resize());
  });
}


// A√ëADE ESTAS DOS NUEVAS FUNCIONES
// AGREGA ESTAS DOS NUEVAS FUNCIONES
function startLiveTimer() {
    stopLiveTimer();
    liveUpdateTimer = setInterval(() => {
        if (!isLiveMode) return;

        const now = new Date();
        const nowMs = now.getTime();
        let seriesUpdates = [];

        currentSensorIds.forEach(id => {
            const sensor = sensorMetadata[id];
            // Solo nos importa si el sensor DEBER√çA estar enviando datos (tiene topic)
            if (!sensor.topic) return;

            const lastMsg = lastMessageTime[id] || 0;
            const isOffline = (nowMs - lastMsg) > 5000; // Consideramos offline tras 5 segundos

            if (isOffline) {
                const buffer = seriesBuffers[id];
                if (buffer && buffer.length > 0) {
                    const lastDataPoint = buffer[buffer.length - 1];
                    // Si el √∫ltimo punto no es ya un "null", a√±adimos uno para crear el hueco.
                    if (lastDataPoint && lastDataPoint[1] !== null) {
                        buffer.push([now, null]);
                        seriesUpdates.push({ id: String(id), data: buffer });
                    }
                }
            }
        });
        
        // Si hubo alguna actualizaci√≥n (alg√∫n sensor pas√≥ a offline), la aplicamos
        if(seriesUpdates.length > 0) {
            unifiedChart.setOption({ series: seriesUpdates }, false, true);
        }

        // Siempre movemos la ventana de tiempo para mantener la sincronizaci√≥n
        applyWindowToDataZoom(nowMs);

    }, 2000); // El marcapasos se ejecuta cada 2 segundos
}

function stopLiveTimer() {
    if (liveUpdateTimer) {
        clearInterval(liveUpdateTimer);
        liveUpdateTimer = null;
    }
}

function stopLiveTimer() {
    if (liveUpdateTimer) {
        clearInterval(liveUpdateTimer);
        liveUpdateTimer = null;
    }
}

  function initRangeChips(){
    chipsWrap.find('.chip').removeClass('active');
    chipsWrap.find(`[data-range="${currentRange}"]`).addClass('active');

    chipsWrap.off('click', '.chip').on('click', '.chip', function(){
      const range = $(this).data('range');
      if (range === currentRange) return;
      currentRange = range;
      chipsWrap.find('.chip').removeClass('active');
      $(this).addClass('active');
      isLiveMode = true;
      setLiveUI(true);
      requestHistory(currentRange);
    });

    backToLiveBtn.off('click').on('click', function(){
      isLiveMode = true;
      setLiveUI(true);
      // reencuadrar a la derecha
      applyWindowToDataZoom(Date.now());
    });
  }

  function setLiveUI(on){
    if (on){
      liveIndicator.addClass('on').text('En vivo');
      backToLiveBtn.hide();
    } else {
      liveIndicator.removeClass('on').text('En pausa');
      backToLiveBtn.show();
    }
  }

  function requestHistory(range){
    if (!currentStationId) return;
    $.getJSON(`/api/stations/${currentStationId}/history?timescale=${encodeURIComponent(range)}`, function(history){
      // Vaciar buffers y rellenar con hist√≥rico
      for (const sid of currentSensorIds){
        seriesBuffers[sid] = [];
        const arr = history[sid] || [];
        for (const [tsISO, val] of arr){
          seriesBuffers[sid].push([ new Date(tsISO), Number(val) ]);
        }
      }
      // Poner datos en el chart
      const seriesUpdates = currentSensorIds.map(sid => ({ id:String(sid), data: seriesBuffers[sid] }));
      unifiedChart.setOption({ series: seriesUpdates }, false, true);

      // Encajar ventana a ‚Äúahora - rango .. ahora‚Äù
      applyWindowToDataZoom(Date.now());
    });
  }

  function applyWindowToDataZoom(nowMs){
    const endV = new Date(nowMs);
    const startV = new Date(nowMs - RANGE_MS[currentRange]);
    // actualiza ambos dataZoom (inside + slider)
    const xIdx = currentSensorIds.map((_, i) => i);
    unifiedChart.setOption({
      dataZoom: [
        { type:'inside', xAxisIndex:xIdx, startValue: startV, endValue: endV },
        { type:'slider', xAxisIndex:xIdx, startValue: startV, endValue: endV, bottom:2 }
      ]
    });
  }

  // ============================
  // OPCI√ìN ECHARTS (igual base)
  // ============================
function buildUnifiedChartOption(sensors) {
  const n = sensors.length;

  // ====== LAYOUT EN P√çXELES (gap real de 1‚Äì2 px) ======
  // Puedes ajustar estos 3 valores a tu gusto:
  const GAP_PX          = 15;   // << separaci√≥n vertical entre subgr√°ficos (1‚Äì2 px)
  const TOP_MARGIN_PX   = 12;   // margen superior del √°rea de grids
  const BOTTOM_MARGIN_PX= 62;  // margen inferior para labels del √∫ltimo eje + slider

  // m√°rgenes laterales (en %) para conservar el eje Y legible
  const LEFT_MARGIN_PCT  = 4;
  const RIGHT_MARGIN_PCT = 2;

  // Altura total disponible del chart en px
  const CH = (typeof unifiedChart?.getHeight === 'function')
    ? unifiedChart.getHeight()
    : document.getElementById('unified-chart').clientHeight;

  const usablePx = CH - TOP_MARGIN_PX - BOTTOM_MARGIN_PX - (GAP_PX * (n - 1));
  const eachHPx  = usablePx / n;

  const grids = [], xAxes = [], yAxes = [], series = [], graphics = [];
  const colorPalette = ['#5470C6','#91CC75','#FAC858','#EE6666','#73C0DE','#3BA272','#FC8452','#9A60B4','#EA7CCC'];

  sensors.forEach((s, i) => {
    const topPx = Math.round(TOP_MARGIN_PX + i * (eachHPx + GAP_PX));

    // Grid en p√≠xeles (top/height) y % a los lados
    grids.push({
      top: topPx, height: Math.round(eachHPx),
      left: `${LEFT_MARGIN_PCT}%`, right: `${RIGHT_MARGIN_PCT}%`
    });

    xAxes.push({
      type: 'time', gridIndex: i, axisPointer: { show: true, snap: true },
      axisLabel: { show: i === n - 1, hideOverlap: true },
      axisLine:  { show: i === n - 1 }, axisTick: { show: i === n - 1 }, splitLine: { show: i === n - 1 }
    });

    yAxes.push({
      type: 'value', gridIndex: i, splitNumber: 3,
      min: isFinite(s.min_value) ? s.min_value : null,
      max: isFinite(s.max_value) ? s.max_value : null,
      axisLabel: {
        formatter: (v) => Math.abs(v) >= 1000 ? (v/1000).toFixed(1).replace(/\.0$/,'')+'k' : v
      }
    });

    // Serie con markLine en y=0 para que la l√≠nea base destaque
    series.push({
      name: s.name, id: String(s.id), type: 'line', showSymbol: false,
      xAxisIndex: i, yAxisIndex: i, data: [],
      lineStyle: { width: 2, color: colorPalette[i % colorPalette.length] },
      itemStyle: { color: colorPalette[i % colorPalette.length] },
      markLine: {
        symbol: 'none', silent: true,
        lineStyle: { color: '#9CA3AF', width: 1.5, opacity: 0.9 },
        data: [{ yAxis: 0 }]
      }
    });

    // Etiqueta del sensor encima de cada grid
    graphics.push({
      type:'text',
      left:`${LEFT_MARGIN_PCT + 0.5}%`,
      top: topPx + 2,
      style:{ text:s.name, fontSize:12, fill:'#495057', backgroundColor:'rgba(255,255,255,0.6)', padding:[2,4] },
      silent:true
    });
  });

  const xIdx = sensors.map((_, i) => i);
  const dataZoom = [
    { type:'inside', xAxisIndex:xIdx },
    { type:'slider', xAxisIndex:xIdx, bottom:2 }
  ];

  // Tooltip unificado (igual que lo tienes)
  const tooltip = {
    trigger:'axis',
    axisPointer:{ type:'cross', link:[{ xAxisIndex:'all' }], snap:true },
    confine:true,
    formatter: function(params){
      if(!params || !params.length) return '';
      const tsAny = params[0].axisValue ?? params[0].value?.[0];
      const targetMs = (tsAny instanceof Date) ? tsAny.getTime() : new Date(tsAny).getTime();
      const d = new Date(targetMs);
      const dd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}
                  ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;

      const highlightedName = params[0].seriesName;
      let html = `<div style="min-width:260px"><div style="font-weight:700;margin-bottom:6px">${dd}</div>`;

      const highlighted = Object.values(sensorMetadata).find(s => s.name === highlightedName);
      if (highlighted) {
        const sid = highlighted.id;
        const nearest = nearestValue(seriesBuffers[sid], targetMs);
        const unit = highlighted.unit || '';
        const color = colorPalette[(sensorIndexById[sid] ?? 0) % colorPalette.length];
        const valText = (nearest.value == null) ? '--' : Number(nearest.value).toFixed(2);
        html += `<div style="display:flex;justify-content:space-between;gap:12px;align-items:baseline;margin-bottom:6px;">
                   <span style="display:flex;align-items:center;gap:6px;">
                     <span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color}"></span>
                     <span style="font-weight:600">${highlighted.name}</span>
                   </span>
                   <span style="font-weight:700;font-size:16px;">${valText} ${unit}</span>
                 </div>`;
      }

      currentSensorIds.forEach((sid) => {
        const s = sensorMetadata[sid];
        if (!s || s.name === highlightedName) return;
        const nearest = nearestValue(seriesBuffers[sid], targetMs);
        const unit  = s.unit || '';
        const color = colorPalette[(sensorIndexById[sid] ?? 0) % colorPalette.length];
        const valText = (nearest.value == null) ? '--' : Number(nearest.value).toFixed(2);
        html += `<div style="display:flex;justify-content:space-between;gap:12px;">
                   <span style="display:flex;align-items:center;gap:6px;">
                     <span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color}"></span>
                     ${s.name}
                   </span>
                   <span style="font-weight:600">${valText} ${unit}</span>
                 </div>`;
      });

      html += `</div>`;
      return html;
    }
  };

  return { animation:false, grid:grids, xAxis:xAxes, yAxis:yAxes, series, dataZoom, tooltip, graphic:graphics };
}

function findSensorByName(name) {
    const s = Object.values(sensorMetadata).find(x => x.name === name);
    return s || null;
  }

  // ============================
  // MQTT ‚Üí actualizar + ventana m√≥vil
  // ============================
  // REEMPLAZA ESTA FUNCI√ìN
// REEMPLAZA ESTA FUNCI√ìN
// REEMPLAZA ESTA FUNCI√ìN
function onMessageArrived(message) {
  const rawTopic = message.destinationName;
  const payload  = message.payloadString;

  // Probamos las variantes sin tocar la API
  const keysToTry = [rawTopic];
  if (rawTopic.endsWith('/')) keysToTry.push(rawTopic.slice(0, -1));
  else                        keysToTry.push(rawTopic + '/');

  let sensorId;
  for (const k of keysToTry) {
    if (k in topicToSensorIdMap) { sensorId = topicToSensorIdMap[k]; break; }
  }

  if (sensorId !== undefined) {
    const val = parseFloat(payload);
    if (!Number.isNaN(val)) {
      lastMessageTime[sensorId] = Date.now();
      // (opcional) visibilidad del flujo
      // console.log("‚Üí hit", rawTopic, "-> sensor", sensorId, "=", val);
      updateChartData(sensorId, val);
    }
  } else {
    // (opcional) ver misses:
    // console.warn("Topic no mapeado:", rawTopic);
  }
}



  // REEMPLAZA ESTA FUNCI√ìN
// REEMPLAZA ESTA FUNCI√ìN
function updateChartData(sensorId, value) {
    const now = new Date();
    const nowMs = now.getTime();

    // 1. Actualiza la tarjeta y el buffer del sensor que recibi√≥ datos
    $('#value-display-' + sensorId).text(Number(value).toFixed(2));
    const activeBuffer = seriesBuffers[sensorId];
    activeBuffer.push([now, value]);

    // 2. Prepara la actualizaci√≥n para ECharts
    let seriesUpdates = [{
        id: String(sensorId),
        data: activeBuffer
    }];

    // 3. ¬°LA SOLUCI√ìN! Extiende las l√≠neas de los otros sensores
    currentSensorIds.forEach(id => {
        // Si es el sensor que ya actualizamos, lo saltamos
        if (id === sensorId) return;

        const buffer = seriesBuffers[id];
        if (buffer && buffer.length > 0) {
            // Tomamos el √∫ltimo valor conocido
            const lastValue = buffer[buffer.length - 1][1];
            // Y a√±adimos un nuevo punto en el tiempo actual con el MISMO valor
            buffer.push([now, lastValue]);
            
            // A√±adimos esta serie a la actualizaci√≥n tambi√©n
            seriesUpdates.push({
                id: String(id),
                data: buffer
            });
        }
    });

    // 4. Purga los datos antiguos de TODOS los buffers
    if (isLiveMode) {
        const minTime = nowMs - RANGE_MS[currentRange];
        for (const sid in seriesBuffers) {
            const buf = seriesBuffers[sid];
            while (buf.length && buf[0][0].getTime() < minTime) {
                buf.shift();
            }
        }
    }

    // 5. Aplica todos los cambios al gr√°fico de una sola vez
    unifiedChart.setOption({ series: seriesUpdates }, false, true);

    // 6. Mueve la ventana de tiempo si estamos en vivo
    if (isLiveMode) {
        applyWindowToDataZoom(nowMs);
    }
}

  // Busca el punto m√°s cercano en el buffer [ [Date, value], ... ] al timestamp targetMs


function nearestValue(buf, targetMs){
  const n = buf ? buf.length : 0;
  if (!n) return { value: null, time: null };
  // binaria en tiempos crecientes
  let lo = 0, hi = n - 1;
  while (lo < hi) {
    const mid = (lo + hi) >> 1;
    const midTs = buf[mid][0].getTime();
    if (midTs < targetMs) lo = mid + 1;
    else hi = mid;
  }
  let idx = lo;
  if (idx > 0) {
    const t0 = buf[idx-1][0].getTime(), t1 = buf[idx][0].getTime();
    if (Math.abs(targetMs - t0) <= Math.abs(targetMs - t1)) idx = idx - 1;
  }
  return { value: buf[idx][1], time: buf[idx][0] };
}

});
</script>
{% endblock %}


