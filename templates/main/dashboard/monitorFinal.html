{% extends 'main/dashboard.html' %}
{% load static %}

{% block fixedbar %}
{# Este bloque ahora est√° vac√≠o, como solicitaste #}
{% endblock %}

{% block content %}
<!--Page content-->
<div id="page-content">
  <div class="row">
    <div class="col-lg-12">
      <div class="panel monitor-panel">

        <!-- BARRA SUPERIOR HORIZONTAL -->
        <div class="panel-heading compact">
          <div class="monitor-toolbar">
            <h3 class="panel-title" id="chart-panel-title">Monitor en Tiempo Real</h3>


<div class="toolbar-group station">
  <label class="toolbar-label">ESTACI√ìN</label>
  <!-- Select + bot√≥n en l√≠nea -->
  <div class="station-input">
    <select id="station-selector" class="form-control form-control-sm">
      <option value="">Seleccione una estaci√≥n...</option>
      {% for station in stations %}
        <option value="{{ station.id }}">{{ station.name }}</option>
      {% endfor %}
    </select>

    <button type="button" id="load-sensors-btn" class="btn btn-primary btn-sm">
      Consultar
    </button>
  </div>
</div>

            <div class="toolbar-group">
              <div class="range-chips" id="range-chips">
                <button class="chip active" data-range="5m">5 min</button>
                <button class="chip" data-range="30m">30 min</button>
                <button class="chip" data-range="1h">1 h</button>
                <button class="chip" data-range="3h">3 h</button>
              </div>
              <span id="live-indicator" class="live-indicator on">En vivo</span>
              <button id="back-to-live" class="btn btn-link btn-xs" style="display:none;">Volver al vivo</button>
            </div>
          </div>
        </div>

        <!-- CONTENIDO -->
        <div class="panel-body monitor-flex">
          <!-- IZQUIERDA: gr√°fico -->
          <div class="chart-wrap">
            <div id="unified-chart"></div>
          </div>

          <!-- DERECHA: SOLO valores en vivo -->
          <aside class="side-wrap">
            <div class="panel values-panel">
              
              <div class="panel-body" id="values-panel"></div>
            </div>
          </aside>
        </div>

      </div>
    </div>
  </div>
</div>

<style>
  /* ===== Layout compacto ===== */
  .monitor-panel .panel-heading.compact{ padding:5px 7px; }
  .monitor-toolbar{
    position:relative; z-index:3;  /* asegura clics por encima de cualquier canvas */
    display:flex; align-items:center; gap:12px; flex-wrap:wrap;
  }
  .monitor-toolbar .panel-title{ margin:0 8px 0 0; font-size:16px; font-weight:600; }
  .toolbar-group{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .toolbar-label{ margin:0; font-size:12px; text-transform:uppercase; color:#6c757d; }

  .monitor-flex{ display:flex; gap:12px; align-items:stretch; }
  .chart-wrap{ flex:1 1 auto; min-width:0; }
  #unified-chart{ width:100%; height:78vh; }

  .side-wrap{ width:280px; flex:0 0 280px; display:flex; flex-direction:column; max-height:78vh; }
  .values-panel{ flex:1 1 auto; overflow:auto; margin-bottom:0; }

  /* Tarjetas de valores */
  #values-panel .live-card{
    border:1px solid #e9ecef; border-radius:10px; padding:10px 12px; margin-bottom:10px;
    display:flex; justify-content:space-between; align-items:baseline; background:#fff;
  }
  #values-panel .live-card .name{ font-weight:600; }
  #values-panel .live-card .val{ font-size:1.35em; font-weight:300; }
  #values-panel .live-card .unit{ color:#6c757d; font-size:.9em; margin-left:4px; }

  /* Chips */
  .range-chips{ display:flex; flex-wrap:wrap; gap:8px; }
  .range-chips .chip{
    border:1px solid #cfd4da; border-radius:999px; padding:6px 12px;
    background:#fff; font-size:12px; cursor:pointer;
  }
  .range-chips .chip.active{ background:#0d6efd; color:#fff; border-color:#0d6efd; }

  .live-indicator{ font-size:12px; color:#6c757d; }
  .live-indicator.on::before{
    content:''; display:inline-block; width:8px; height:8px; border-radius:50%; background:#28a745; margin-right:6px;
    box-shadow:0 0 0 2px rgba(40,167,69,.15);
  }

  /* Responsive */
  @media (max-width: 992px){
    .monitor-flex{ flex-direction:column; }
    .side-wrap{ width:100%; flex-basis:auto; max-height:none; }
    #unified-chart{ height:60vh; }
  }
  @media (max-width: 576px){
    #unified-chart{ height:55vh; }
  }

  /* Mantener select + bot√≥n en la misma l√≠nea y que el bot√≥n NO ‚Äúsalte‚Äù hacia abajo */
.toolbar-group.station { flex-wrap: nowrap; }

.station-input{
  display: flex;
  align-items: center;
  gap: 8px;
  white-space: nowrap;          /* evita el salto del bot√≥n */
}

.station-input select{ min-width: 260px; }   /* ancho c√≥modo; ajusta si quieres */
#load-sensors-btn{ white-space: nowrap; }    /* el texto no se parte */

/* Un poco m√°s de aire debajo de la barra para que nunca ‚Äútoque‚Äù el chart */
.monitor-panel .panel-heading.compact{ padding-bottom: 12px; }

</style>
{% endblock %}



{% block script %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"></script>

<script>
$(function () {
  // ============================
  // ESTADO GLOBAL
  // ============================
  let mqttClient = null;
  let currentSubscriptions = [];
  let currentStationName = '';
  let currentStationId = null;

  let sensorMetadata = {};     // { id: {...} }
  let sensorIndexById = {};    // { id: idx }
  let seriesBuffers = {};      // { id: [ [Date, value], ... ] }
  let currentSensorIds = [];   // orden de render

  // Rango y vivo
  const RANGE_MS = { '5m': 5*60*1000, '30m': 30*60*1000, '1h': 60*60*1000, '3h': 3*60*60*1000 };
  let currentRange = '5m';     // por defecto
  let isLiveMode   = true;     // autoscroll activo

  // Para nearestValue del tooltip que ya tienes
  let activeAxisIndex = null;

  // DOM
  const stationSelector  = $('#station-selector');
  const loadButton       = $('#load-sensors-btn');
  const valuesPanel      = $('#values-panel');
  const chipsWrap        = $('#range-chips');
  const liveIndicator    = $('#live-indicator');
  const backToLiveBtn    = $('#back-to-live');

  const chartDom         = document.getElementById('unified-chart');
  const unifiedChart     = echarts.init(chartDom);

  // ============================
  // MQTT
  // ============================
  initMQTTClient();
  stationSelector.on('change', () => loadButton.prop('disabled', !stationSelector.val()));
  loadButton.prop('disabled', !stationSelector.val());
  loadButton.on('click', () => {
    const stationId = stationSelector.val();
    if (stationId) fetchAndRenderUnifiedChart(stationId);
  });

  function initMQTTClient() {
    const clientId = "auralis_dashboard_" + Math.random().toString(16).substr(2, 8);
    try {
      mqttClient = new Paho.MQTT.Client("{{ mqtt_broker_ip }}", Number("{{ mqtt_broker_port }}"), "/", clientId);
      mqttClient.onConnectionLost = onConnectionLost;
      mqttClient.onMessageArrived = onMessageArrived;
      mqttClient.connect({
        onSuccess: () => console.log("MQTT Conectado"),
        onFailure: (e) => console.error("Conexi√≥n MQTT fallida:", e),
        useSSL: false, keepAliveInterval: 60
      });
    } catch (e) { console.error("Error creando cliente MQTT:", e); }
  }
  function onConnectionLost(resp) {
    if (resp.errorCode !== 0) {
      console.log("Conexi√≥n MQTT perdida:", resp.errorMessage);
      setTimeout(initMQTTClient, 5000);
    }
  }
  function subscribeToTopic(topic) {
    if (mqttClient && mqttClient.isConnected()) {
      mqttClient.subscribe(topic);
      currentSubscriptions.push(topic);
    }
  }
  function unsubscribeFromAllTopics() {
    if (mqttClient && mqttClient.isConnected()) {
      currentSubscriptions.forEach(t => mqttClient.unsubscribe(t));
    }
    currentSubscriptions = [];
  }

  // ============================
  // CARGA ESTACI√ìN + HIST√ìRICO
  // ============================
  function fetchAndRenderUnifiedChart(stationId) {
  unsubscribeFromAllTopics();

  // reset
  currentStationId = stationId;
  sensorMetadata = {}; sensorIndexById = {}; seriesBuffers = {};
  currentSensorIds = []; activeAxisIndex = null;
  unifiedChart.clear(); valuesPanel.empty();
  isLiveMode = true;
  setLiveUI(true);

  $.getJSON(`/api/stations/${stationId}/sensors/`, function (response) {
    if (!response.sensors || response.sensors.length === 0) return;

    currentStationName = response.station_name;
    $('#chart-panel-title').text(`Monitor en Tiempo Real - ${currentStationName}`);

    currentSensorIds = response.sensors.map(s => s.id);
    response.sensors.forEach((s, i) => {
      sensorMetadata[s.id] = s;
      sensorIndexById[s.id] = i;
      seriesBuffers[s.id] = [];
      // tarjetas
      valuesPanel.append(`
        <div class="live-card" id="live-card-${s.id}">
          <span class="name">${s.name}</span>
          <span><span class="val" id="value-display-${s.id}">--</span>
          <span class="unit">${s.unit || ''}</span></span>
        </div>`);
    });

    // Construir chart y setear opci√≥n base
    const option = buildUnifiedChartOption(response.sensors);
    unifiedChart.setOption(option, true);

    // Detectar grilla activa para tooltip mixto (si lo est√°s usando)
    unifiedChart.off('updateAxisPointer');
    unifiedChart.on('updateAxisPointer', function (e) {
      if (e.axesInfo && e.axesInfo.length) activeAxisIndex = e.axesInfo[0].axisIndex;
    });

    // Eventos para pausar/reanudar vivo seg√∫n el slider
    unifiedChart.off('dataZoom');
    unifiedChart.on('dataZoom', function(){
      // tomamos el slider (el segundo dataZoom que es "slider")
      const opt = unifiedChart.getOption();
      const dz = (opt.dataZoom && opt.dataZoom.length > 1) ? opt.dataZoom[1] : null;
      if (!dz) return;
      // Si el extremo derecho est√° ‚Äúcasi‚Äù al 100%, consideramos vivo.
      const atRight = (typeof dz.end === 'number') ? (dz.end > 99) : true;
      setLiveUI(atRight);
      isLiveMode = atRight;
    });

    // üîÅ SUSCRIPCI√ìN √öNICA POR ESTACI√ìN (wildcard): "/Estacion/+/"
    const stationWildcard = `/${currentStationName}/+/`;
    subscribeToTopic(stationWildcard);

    // Cargar hist√≥rico PARA EL RANGO ACTUAL (5m por defecto)
    requestHistory(currentRange);

    // Chips
    initRangeChips();

    // Resize
    setTimeout(() => unifiedChart.resize(), 0);
    $(window).off('resize._auralis').on('resize._auralis', () => unifiedChart.resize());
  });
}



  function initRangeChips(){
    chipsWrap.find('.chip').removeClass('active');
    chipsWrap.find(`[data-range="${currentRange}"]`).addClass('active');

    chipsWrap.off('click', '.chip').on('click', '.chip', function(){
      const range = $(this).data('range');
      if (range === currentRange) return;
      currentRange = range;
      chipsWrap.find('.chip').removeClass('active');
      $(this).addClass('active');
      isLiveMode = true;
      setLiveUI(true);
      requestHistory(currentRange);
    });

    backToLiveBtn.off('click').on('click', function(){
      isLiveMode = true;
      setLiveUI(true);
      // reencuadrar a la derecha
      applyWindowToDataZoom(Date.now());
    });
  }

  function setLiveUI(on){
    if (on){
      liveIndicator.addClass('on').text('En vivo');
      backToLiveBtn.hide();
    } else {
      liveIndicator.removeClass('on').text('En pausa');
      backToLiveBtn.show();
    }
  }

  function requestHistory(range){
    if (!currentStationId) return;
    $.getJSON(`/api/stations/${currentStationId}/history?timescale=${encodeURIComponent(range)}`, function(history){
      // Vaciar buffers y rellenar con hist√≥rico
      for (const sid of currentSensorIds){
        seriesBuffers[sid] = [];
        const arr = history[sid] || [];
        for (const [tsISO, val] of arr){
          seriesBuffers[sid].push([ new Date(tsISO), Number(val) ]);
        }
      }
      // Poner datos en el chart
      const seriesUpdates = currentSensorIds.map(sid => ({ id:String(sid), data: seriesBuffers[sid] }));
      unifiedChart.setOption({ series: seriesUpdates }, false, true);

      // Encajar ventana a ‚Äúahora - rango .. ahora‚Äù
      applyWindowToDataZoom(Date.now());
    });
  }

  function applyWindowToDataZoom(nowMs){
    const endV = new Date(nowMs);
    const startV = new Date(nowMs - RANGE_MS[currentRange]);
    // actualiza ambos dataZoom (inside + slider)
    const xIdx = currentSensorIds.map((_, i) => i);
    unifiedChart.setOption({
      dataZoom: [
        { type:'inside', xAxisIndex:xIdx, startValue: startV, endValue: endV },
        { type:'slider', xAxisIndex:xIdx, startValue: startV, endValue: endV, bottom:2 }
      ]
    });
  }

  // ============================
  // OPCI√ìN ECHARTS (igual base)
  // ============================
function buildUnifiedChartOption(sensors) {
  const n = sensors.length;

  // ====== LAYOUT EN P√çXELES (gap real de 1‚Äì2 px) ======
  // Puedes ajustar estos 3 valores a tu gusto:
  const GAP_PX          = 15;   // << separaci√≥n vertical entre subgr√°ficos (1‚Äì2 px)
  const TOP_MARGIN_PX   = 12;   // margen superior del √°rea de grids
  const BOTTOM_MARGIN_PX= 62;  // margen inferior para labels del √∫ltimo eje + slider

  // m√°rgenes laterales (en %) para conservar el eje Y legible
  const LEFT_MARGIN_PCT  = 4;
  const RIGHT_MARGIN_PCT = 2;

  // Altura total disponible del chart en px
  const CH = (typeof unifiedChart?.getHeight === 'function')
    ? unifiedChart.getHeight()
    : document.getElementById('unified-chart').clientHeight;

  const usablePx = CH - TOP_MARGIN_PX - BOTTOM_MARGIN_PX - (GAP_PX * (n - 1));
  const eachHPx  = usablePx / n;

  const grids = [], xAxes = [], yAxes = [], series = [], graphics = [];
  const colorPalette = ['#5470C6','#91CC75','#FAC858','#EE6666','#73C0DE','#3BA272','#FC8452','#9A60B4','#EA7CCC'];

  sensors.forEach((s, i) => {
    const topPx = Math.round(TOP_MARGIN_PX + i * (eachHPx + GAP_PX));

    // Grid en p√≠xeles (top/height) y % a los lados
    grids.push({
      top: topPx, height: Math.round(eachHPx),
      left: `${LEFT_MARGIN_PCT}%`, right: `${RIGHT_MARGIN_PCT}%`
    });

    xAxes.push({
      type: 'time', gridIndex: i, axisPointer: { show: true, snap: true },
      axisLabel: { show: i === n - 1, hideOverlap: true },
      axisLine:  { show: i === n - 1 }, axisTick: { show: i === n - 1 }, splitLine: { show: i === n - 1 }
    });

    yAxes.push({
      type: 'value', gridIndex: i, splitNumber: 3,
      min: isFinite(s.min_value) ? s.min_value : null,
      max: isFinite(s.max_value) ? s.max_value : null,
      axisLabel: {
        formatter: (v) => Math.abs(v) >= 1000 ? (v/1000).toFixed(1).replace(/\.0$/,'')+'k' : v
      }
    });

    // Serie con markLine en y=0 para que la l√≠nea base destaque
    series.push({
      name: s.name, id: String(s.id), type: 'line', showSymbol: false,
      xAxisIndex: i, yAxisIndex: i, data: [],
      lineStyle: { width: 2, color: colorPalette[i % colorPalette.length] },
      itemStyle: { color: colorPalette[i % colorPalette.length] },
      markLine: {
        symbol: 'none', silent: true,
        lineStyle: { color: '#9CA3AF', width: 1.5, opacity: 0.9 },
        data: [{ yAxis: 0 }]
      }
    });

    // Etiqueta del sensor encima de cada grid
    graphics.push({
      type:'text',
      left:`${LEFT_MARGIN_PCT + 0.5}%`,
      top: topPx + 2,
      style:{ text:s.name, fontSize:12, fill:'#495057', backgroundColor:'rgba(255,255,255,0.6)', padding:[2,4] },
      silent:true
    });
  });

  const xIdx = sensors.map((_, i) => i);
  const dataZoom = [
    { type:'inside', xAxisIndex:xIdx },
    { type:'slider', xAxisIndex:xIdx, bottom:2 }
  ];

  // Tooltip unificado (igual que lo tienes)
  const tooltip = {
    trigger:'axis',
    axisPointer:{ type:'cross', link:[{ xAxisIndex:'all' }], snap:true },
    confine:true,
    formatter: function(params){
      if(!params || !params.length) return '';
      const tsAny = params[0].axisValue ?? params[0].value?.[0];
      const targetMs = (tsAny instanceof Date) ? tsAny.getTime() : new Date(tsAny).getTime();
      const d = new Date(targetMs);
      const dd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}
                  ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;

      const highlightedName = params[0].seriesName;
      let html = `<div style="min-width:260px"><div style="font-weight:700;margin-bottom:6px">${dd}</div>`;

      const highlighted = Object.values(sensorMetadata).find(s => s.name === highlightedName);
      if (highlighted) {
        const sid = highlighted.id;
        const nearest = nearestValue(seriesBuffers[sid], targetMs);
        const unit = highlighted.unit || '';
        const color = colorPalette[(sensorIndexById[sid] ?? 0) % colorPalette.length];
        const valText = (nearest.value == null) ? '--' : Number(nearest.value).toFixed(2);
        html += `<div style="display:flex;justify-content:space-between;gap:12px;align-items:baseline;margin-bottom:6px;">
                   <span style="display:flex;align-items:center;gap:6px;">
                     <span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color}"></span>
                     <span style="font-weight:600">${highlighted.name}</span>
                   </span>
                   <span style="font-weight:700;font-size:16px;">${valText} ${unit}</span>
                 </div>`;
      }

      currentSensorIds.forEach((sid) => {
        const s = sensorMetadata[sid];
        if (!s || s.name === highlightedName) return;
        const nearest = nearestValue(seriesBuffers[sid], targetMs);
        const unit  = s.unit || '';
        const color = colorPalette[(sensorIndexById[sid] ?? 0) % colorPalette.length];
        const valText = (nearest.value == null) ? '--' : Number(nearest.value).toFixed(2);
        html += `<div style="display:flex;justify-content:space-between;gap:12px;">
                   <span style="display:flex;align-items:center;gap:6px;">
                     <span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color}"></span>
                     ${s.name}
                   </span>
                   <span style="font-weight:600">${valText} ${unit}</span>
                 </div>`;
      });

      html += `</div>`;
      return html;
    }
  };

  return { animation:false, grid:grids, xAxis:xAxes, yAxis:yAxes, series, dataZoom, tooltip, graphic:graphics };
}




  function findSensorByName(name) {
    const s = Object.values(sensorMetadata).find(x => x.name === name);
    return s || null;
  }

  // ============================
  // MQTT ‚Üí actualizar + ventana m√≥vil
  // ============================
 function onMessageArrived(message) {
  const rawTopic = message.destinationName;   // p.ej. "/Estacion/Sensor/" o "Estacion/Sensor/"
  const payload  = message.payloadString;

  // Normaliza: quita slashes de inicio/fin y divide
  const cleaned = rawTopic.replace(/^\/+|\/+$/g, ''); // "/A/B/" -> "A/B"
  const parts   = cleaned.split('/');                 // ["Estacion","Sensor",...]
  if (parts.length < 2) return;

  const stationFromTopic = parts[0];
  const sensorFromTopic  = parts[1];

  // Debe coincidir con la estaci√≥n actualmente seleccionada
  if (stationFromTopic !== currentStationName) return;

  // Busca sensor por nombre de los cargados v√≠a API
  const sensor = Object.values(sensorMetadata).find(s => s.name === sensorFromTopic);
  if (!sensor) return;

  const val = parseFloat(payload);
  if (Number.isNaN(val)) return;

  updateChartData(sensor.id, val);
}


  function updateChartData(sensorId, value) {
    const now = new Date();

    // Tarjeta (derecha)
    $('#value-display-' + sensorId).text(Number(value).toFixed(2));

    // Buffer (siempre guardamos crudo) y purga por rango
    const buf = seriesBuffers[sensorId];
    buf.push([now, value]);

    // Purga en funci√≥n del rango actual (solo si estamos en "vivo")
    if (isLiveMode) {
      const minTime = now.getTime() - RANGE_MS[currentRange];
      while (buf.length && buf[0][0].getTime() < minTime) buf.shift();
    }

    // Actualizar serie
    unifiedChart.setOption({ series: [{ id:String(sensorId), data: buf }] }, false, true);

    // Si estamos en vivo, movemos la ventana al final (autoscroll)
    if (isLiveMode) {
      applyWindowToDataZoom(now.getTime());
    }
  }

  // Busca el punto m√°s cercano en el buffer [ [Date, value], ... ] al timestamp targetMs
function nearestValue(buf, targetMs){
  const n = buf ? buf.length : 0;
  if (!n) return { value: null, time: null };
  // binaria en tiempos crecientes
  let lo = 0, hi = n - 1;
  while (lo < hi) {
    const mid = (lo + hi) >> 1;
    const midTs = buf[mid][0].getTime();
    if (midTs < targetMs) lo = mid + 1;
    else hi = mid;
  }
  let idx = lo;
  if (idx > 0) {
    const t0 = buf[idx-1][0].getTime(), t1 = buf[idx][0].getTime();
    if (Math.abs(targetMs - t0) <= Math.abs(targetMs - t1)) idx = idx - 1;
  }
  return { value: buf[idx][1], time: buf[idx][0] };
}

});
</script>
{% endblock %}


