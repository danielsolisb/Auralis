{% extends 'main/dashboard.html' %}
{% load static %}

{% block fixedbar %}
{# Este bloque ahora está vacío, como solicitaste #}
{% endblock %}

{% block content %}
<!--Page content-->
<div id="page-content">
  <div class="row">
    <div class="col-lg-12">
      <div class="panel">
        <div class="panel-heading">
          <h3 class="panel-title" id="chart-panel-title">Monitor en Tiempo Real</h3>
        </div>

        <!-- Layout: gráfico a la izquierda (flex-grow) + sidebar derecha (controles + valores) -->
        <div class="panel-body" style="display:flex; gap:16px;">
          <!-- Lado IZQUIERDO: solo el gráfico, ocupa todo el ancho disponible -->
          <div style="flex: 1 1 auto; min-width: 0;">
            <div id="unified-chart" style="width:100%; height:75vh;"></div>

            <!-- Placeholder -->
            
          </div>

          <!-- Lado DERECHO: Controles (arriba) + Valores en vivo (abajo) -->
          <aside style="width: 300px; flex: 0 0 300px; display:flex; flex-direction:column; gap:12px; max-height:75vh;">
            <!-- Controles -->
            <div class="panel" style="margin-bottom:0;">
              <div class="panel-body">
                <div class="pad-all">
                  <span class="pad-ver text-main text-sm text-uppercase text-bold">SELECCIONE ESTACIÓN</span>
                  <div class="form-group">
                    <select id="station-selector" class="form-control">
                      <option value="">Seleccione una estación...</option>
                      {% for station in stations %}
                        <option value="{{ station.id }}">{{ station.name }}</option>
                      {% endfor %}
                    </select>
                  </div>
                  <div class="form-group">
                    <button id="load-sensors-btn" class="btn btn-primary btn-block">Consultar</button>
                  </div>
                </div>
              </div>
            </div>

            <!-- Valores en vivo -->
            <div class="panel" style="flex:1 1 auto; overflow:auto; margin-bottom:0;">
              <div class="panel-heading">
                <h3 class="panel-title">Valores en vivo</h3>
              </div>
              <div class="panel-body" id="values-panel">
                <!-- Se llenará dinámicamente -->
              </div>
            </div>
          </aside>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  /* Tarjetas compactas (panel derecha) */
  #values-panel .live-card {
    border: 1px solid #e9ecef;
    border-radius: 10px;
    padding: 10px 12px;
    margin-bottom: 10px;
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    background: #fff;
  }
  #values-panel .live-card .name { font-weight: 600; }
  #values-panel .live-card .val  { font-size: 1.4em; font-weight: 300; }
  #values-panel .live-card .unit { color: #6c757d; font-size: .9em; margin-left: 4px; }
</style>
{% endblock %}


{% block script %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"></script>

<script>
$(document).ready(function () {
  // ============================
  // ESTADO GLOBAL
  // ============================
  let mqttClient = null;
  let currentSubscriptions = [];
  let currentStationName = '';
  let sensorMetadata = {};         // { sensorId: {...} }
  let sensorIndexById = {};        // { sensorId: i }
  let seriesBuffers = {};          // { sensorId: [[ts,val], ...] }

  const MAX_POINTS = 600;
  const colorPalette = ['#5470C6','#91CC75','#FAC858','#EE6666','#73C0DE','#3BA272','#FC8452','#9A60B4','#EA7CCC'];

  // DOM
  const stationSelector  = $('#station-selector');
  const loadButton       = $('#load-sensors-btn');
  const placeholderText  = $('#placeholder-text');
  const chartPanelTitle  = $('#chart-panel-title');
  const valuesPanel      = $('#values-panel');
  const chartDom         = document.getElementById('unified-chart');
  const unifiedChart     = echarts.init(chartDom);

  // ============================
  // MQTT
  // ============================
  initMQTTClient();

  if (!stationSelector.val()) loadButton.prop('disabled', true);
  stationSelector.on('change', function () {
    loadButton.prop('disabled', !$(this).val());
  });
  loadButton.on('click', function () {
    const stationId = stationSelector.val();
    if (stationId) fetchAndRenderUnifiedChart(stationId);
  });

  function initMQTTClient() {
    const clientId = "auralis_dashboard_" + Math.random().toString(16).substr(2, 8);
    try {
      mqttClient = new Paho.MQTT.Client(
        "{{ mqtt_broker_ip }}",
        Number("{{ mqtt_broker_port }}"),
        "/",
        clientId
      );
      mqttClient.onConnectionLost = onConnectionLost;
      mqttClient.onMessageArrived = onMessageArrived;
      mqttClient.connect({
        onSuccess: onConnect,
        onFailure: (e) => console.error("Conexión MQTT fallida:", e),
        useSSL: false,
        keepAliveInterval: 60
      });
    } catch (e) {
      console.error("Error creando cliente MQTT:", e);
    }
  }
  function onConnect() { console.log("MQTT Conectado"); }
  function onConnectionLost(resp) {
    if (resp.errorCode !== 0) {
      console.log("Conexión MQTT perdida:", resp.errorMessage);
      setTimeout(initMQTTClient, 5000);
    }
  }
  function subscribeToTopic(topic) {
    if (mqttClient && mqttClient.isConnected()) {
      mqttClient.subscribe(topic);
      currentSubscriptions.push(topic);
      console.log(`Suscrito a ${topic}`);
    }
  }
  function unsubscribeFromAllTopics() {
    if (mqttClient && mqttClient.isConnected()) {
      currentSubscriptions.forEach(t => mqttClient.unsubscribe(t));
    }
    currentSubscriptions = [];
  }

  // ============================
  // CARGAR SENSORES Y ARMAR CHART
  // ============================
  function fetchAndRenderUnifiedChart(stationId) {
    unsubscribeFromAllTopics();

    sensorMetadata   = {};
    sensorIndexById  = {};
    seriesBuffers    = {};
    unifiedChart.clear();
    valuesPanel.empty();
    placeholderText.hide();

    $.ajax({
      url: `/api/stations/${stationId}/sensors/`,
      method: 'GET',
      success: function (response) {
        if (!response.sensors || response.sensors.length === 0) {
          placeholderText.html('<h3 class="text-muted">No hay sensores disponibles para esta estación</h3>').show();
          return;
        }

        currentStationName = response.station_name;
        chartPanelTitle.text(`Monitor en Tiempo Real - ${currentStationName}`);

        // Tarjetas (derecha)
        response.sensors.forEach((s, i) => {
          sensorMetadata[s.id] = s;
          sensorIndexById[s.id] = i;
          seriesBuffers[s.id] = [];

          valuesPanel.append(`
            <div class="live-card" id="live-card-${s.id}">
              <span class="name">${s.name}</span>
              <span>
                <span class="val" id="value-display-${s.id}">--</span>
                <span class="unit">${s.unit || ''}</span>
              </span>
            </div>
          `);
        });

        // Chart
        const option = buildUnifiedChartOption(response.sensors);
        unifiedChart.setOption(option, true);

        // Suscripciones MQTT
        response.sensors.forEach(sensor => {
          const topic = `${currentStationName}/${sensor.name}/`;
          subscribeToTopic(topic);
        });

        setTimeout(() => unifiedChart.resize(), 0);
        $(window).off('resize._auralis').on('resize._auralis', () => unifiedChart.resize());
      },
      error: function (err) {
        console.error(err);
        placeholderText.html(`<h3 class="text-danger">Error al cargar los sensores: ${err.statusText || err}</h3>`).show();
      }
    });
  }

  // ============================
  // OPCIÓN ECHARTS (una sola línea de tiempo + etiquetas por grid)
  // ============================
  function buildUnifiedChartOption(sensors) {
    const n = sensors.length;

    // Layout vertical
    const leftMarginPct   = 9;   // %
    const rightMarginPct  = 3;   // %
    const topMargin = 6;         // %
    const bottomMargin = 12;     // %
    const gap = 2;               // % entre grillas
    const usable = 100 - topMargin - bottomMargin - (gap * (n - 1));
    const eachH = usable / n;

    const grids = [];
    const xAxes = [];
    const yAxes = [];
    const series = [];
    const graphics = []; // etiquetas (título) por grid

    sensors.forEach((s, i) => {
      const top = topMargin + i * (eachH + gap);

      // Grid por sensor
      grids.push({
        top: `${top}%`,
        height: `${eachH}%`,
        left: `${leftMarginPct}%`,
        right: `${rightMarginPct}%`
      });

      // Un xAxis por grid: SOLO el último visible
      xAxes.push({
        type: 'time',
        gridIndex: i,
        axisLabel: { show: i === n - 1, hideOverlap: true },
        axisLine:  { show: i === n - 1 },
        axisTick:  { show: i === n - 1 },
        splitLine: { show: i === n - 1 },
        axisPointer: { show: true }
      });

      // yAxis sin "name" para que no invada otros grids
      yAxes.push({
        type: 'value',
        gridIndex: i,
        splitNumber: 3,
        min: isFinite(s.min_value) ? s.min_value : null,
        max: isFinite(s.max_value) ? s.max_value : null,
        axisLabel: {
          formatter: function (value) {
            if (value === 0) return '0';
            if (Math.abs(value) >= 1000) return (value / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
            return value;
          }
        }
      });

      // Serie
      series.push({
        name: s.name,
        id: String(s.id),
        type: 'line',
        showSymbol: false,
        xAxisIndex: i,
        yAxisIndex: i,
        data: [],
        lineStyle: { width: 2, color: colorPalette[i % colorPalette.length] },
        itemStyle: { color: colorPalette[i % colorPalette.length] }
      });

      // Etiqueta del sensor DENTRO del área del grid (arriba-izquierda)
      // La colocamos ligeramente dentro del margen izquierdo del grid.
      graphics.push({
        type: 'text',
        left: `${leftMarginPct + 1}%`,   // 1% dentro del grid
        top: `${top + 1}%`,              // 1% debajo del borde superior del grid
        style: {
          text: s.name,
          fontSize: 12,
          fill: '#495057',
          backgroundColor: 'rgba(255,255,255,0.6)',
          padding: [2,4]
        },
        silent: true
      });
    });

    // DataZoom ÚNICO (controla todos los xAxis)
    const xIdx = sensors.map((_, i) => i);
    const dataZoom = [
      { type: 'inside', xAxisIndex: xIdx },
      { type: 'slider', xAxisIndex: xIdx, bottom: 2 }
    ];

    // Tooltip UNIFICADO
    const tooltip = {
      trigger: 'axis',
      axisPointer: {
        type: 'cross',
        link: [{ xAxisIndex: 'all' }]
      },
      confine: true,
      formatter: function (params) {
        if (!params || !params.length) return '';
        const ts = params[0].value[0];
        const d  = new Date(ts);
        const dd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;

        let html = `<div style="min-width:220px"><div style="font-weight:600;margin-bottom:6px">${dd}</div>`;
        params.forEach(p => {
          const sName = p.seriesName;
          const val = (p.value && p.value.length > 1) ? p.value[1] : p.data;
          const unit = (findSensorByName(sName)?.unit) || '';
          html += `
            <div style="display:flex;justify-content:space-between;gap:12px;">
              <span><span style="display:inline-block;width:10px;height:10px;background:${p.color};margin-right:6px;border-radius:50%"></span>${sName}</span>
              <span style="font-weight:600">${Number(val).toFixed(2)} ${unit}</span>
            </div>`;
        });
        html += `</div>`;
        return html;
      }
    };

    return {
      animation: false,
      grid: grids,
      xAxis: xAxes,
      yAxis: yAxes,
      series: series,
      dataZoom: dataZoom,
      tooltip: tooltip,
      graphic: graphics
    };
  }

  function findSensorByName(name) {
    const s = Object.values(sensorMetadata).find(x => x.name === name);
    return s || null;
  }

  // ============================
  // MQTT → actualizar gráfico y tarjetas
  // ============================
  function onMessageArrived(message) {
    const topic = message.destinationName;  // "Station/Sensor/"
    const payload = message.payloadString;

    const t = topic.slice(0, -1).split('/'); // quita "/" final
    if (t.length < 2) return;
    if (t[0] !== currentStationName) return;

    const sensorName = t[1];
    const sensor = Object.values(sensorMetadata).find(s => s.name === sensorName);
    if (!sensor) return;

    const val = parseFloat(payload);
    if (Number.isNaN(val)) return;

    updateChartData(sensor.id, val);
  }

  function updateChartData(sensorId, value) {
    const now = new Date();

    // Actualiza tarjeta (derecha)
    $('#value-display-' + sensorId).text(value.toFixed(2));

    // Buffer y serie
    const buf = seriesBuffers[sensorId];
    buf.push([now, value]);
    if (buf.length > MAX_POINTS) buf.shift();

    unifiedChart.setOption({
      series: [{ id: String(sensorId), data: buf }]
    }, false, true);
  }
});
</script>
{% endblock %}
