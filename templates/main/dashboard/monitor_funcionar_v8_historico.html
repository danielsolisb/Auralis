{% extends 'main/dashboard.html' %}
{% load static %}

{% block fixedbar %}
{# Este bloque ahora está vacío, como solicitaste #}
{% endblock %}

{% block content %}
<!--Page content-->
<div id="page-content">
  <div class="row">
    <div class="col-lg-12">
      <div class="panel monitor-panel">

        <!-- BARRA SUPERIOR HORIZONTAL -->
        <div class="panel-heading compact">
          <div class="monitor-toolbar">
            <h3 class="panel-title" id="chart-panel-title">Monitor en Tiempo Real</h3>


<div class="toolbar-group station">
  <label class="toolbar-label">ESTACIÓN</label>
  <!-- Select + botón en línea -->
  <div class="station-input">
    <select id="station-selector" class="form-control form-control-sm">
      <option value="">Seleccione una estación...</option>
      {% for station in stations %}
        <option value="{{ station.id }}">{{ station.name }}</option>
      {% endfor %}
    </select>

    <button type="button" id="load-sensors-btn" class="btn btn-primary btn-sm">
      Consultar
    </button>
  </div>
</div>

            <div class="toolbar-group">
              <div class="range-chips" id="range-chips">
                <button class="chip active" data-range="5m">5 min</button>
                <button class="chip" data-range="30m">30 min</button>
                <button class="chip" data-range="1h">1 h</button>
                <button class="chip" data-range="3h">3 h</button>
              </div>
              <span id="live-indicator" class="live-indicator on">En vivo</span>
              <button id="back-to-live" class="btn btn-link btn-xs" style="display:none;">Volver al vivo</button>
            </div>
          </div>
        </div>

        <!-- CONTENIDO -->
        <div class="panel-body monitor-flex">
          <!-- IZQUIERDA: gráfico -->
          <div class="chart-wrap">
            <div id="unified-chart"></div>
          </div>

          <!-- DERECHA: SOLO valores en vivo -->
          <aside class="side-wrap">
            <div class="panel values-panel">
              <div class="panel-heading">
                <h3 class="panel-title">Valores en vivo</h3>
              </div>
              <div class="panel-body" id="values-panel"></div>
            </div>
          </aside>
        </div>

      </div>
    </div>
  </div>
</div>

<style>
  /* ===== Layout compacto ===== */
  .monitor-panel .panel-heading.compact{ padding:8px 12px; }
  .monitor-toolbar{
    position:relative; z-index:3;  /* asegura clics por encima de cualquier canvas */
    display:flex; align-items:center; gap:12px; flex-wrap:wrap;
  }
  .monitor-toolbar .panel-title{ margin:0 8px 0 0; font-size:16px; font-weight:600; }
  .toolbar-group{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .toolbar-label{ margin:0; font-size:12px; text-transform:uppercase; color:#6c757d; }

  .monitor-flex{ display:flex; gap:12px; align-items:stretch; }
  .chart-wrap{ flex:1 1 auto; min-width:0; }
  #unified-chart{ width:100%; height:78vh; }

  .side-wrap{ width:280px; flex:0 0 280px; display:flex; flex-direction:column; max-height:78vh; }
  .values-panel{ flex:1 1 auto; overflow:auto; margin-bottom:0; }

  /* Tarjetas de valores */
  #values-panel .live-card{
    border:1px solid #e9ecef; border-radius:10px; padding:10px 12px; margin-bottom:10px;
    display:flex; justify-content:space-between; align-items:baseline; background:#fff;
  }
  #values-panel .live-card .name{ font-weight:600; }
  #values-panel .live-card .val{ font-size:1.35em; font-weight:300; }
  #values-panel .live-card .unit{ color:#6c757d; font-size:.9em; margin-left:4px; }

  /* Chips */
  .range-chips{ display:flex; flex-wrap:wrap; gap:8px; }
  .range-chips .chip{
    border:1px solid #cfd4da; border-radius:999px; padding:6px 12px;
    background:#fff; font-size:12px; cursor:pointer;
  }
  .range-chips .chip.active{ background:#0d6efd; color:#fff; border-color:#0d6efd; }

  .live-indicator{ font-size:12px; color:#6c757d; }
  .live-indicator.on::before{
    content:''; display:inline-block; width:8px; height:8px; border-radius:50%; background:#28a745; margin-right:6px;
    box-shadow:0 0 0 2px rgba(40,167,69,.15);
  }

  /* Responsive */
  @media (max-width: 992px){
    .monitor-flex{ flex-direction:column; }
    .side-wrap{ width:100%; flex-basis:auto; max-height:none; }
    #unified-chart{ height:60vh; }
  }
  @media (max-width: 576px){
    #unified-chart{ height:55vh; }
  }

  /* Mantener select + botón en la misma línea y que el botón NO “salte” hacia abajo */
.toolbar-group.station { flex-wrap: nowrap; }

.station-input{
  display: flex;
  align-items: center;
  gap: 8px;
  white-space: nowrap;          /* evita el salto del botón */
}

.station-input select{ min-width: 260px; }   /* ancho cómodo; ajusta si quieres */
#load-sensors-btn{ white-space: nowrap; }    /* el texto no se parte */

/* Un poco más de aire debajo de la barra para que nunca “toque” el chart */
.monitor-panel .panel-heading.compact{ padding-bottom: 12px; }

</style>
{% endblock %}



{% block script %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"></script>

<script>
$(function () {
  // ============================
  // ESTADO GLOBAL
  // ============================
  let mqttClient = null;
  let currentSubscriptions = [];
  let currentStationName = '';
  let currentStationId = null;

  let sensorMetadata = {};     // { id: {...} }
  let sensorIndexById = {};    // { id: idx }
  let seriesBuffers = {};      // { id: [ [Date, value], ... ] }
  let currentSensorIds = [];   // orden de render

  // Rango y vivo
  const RANGE_MS = { '5m': 5*60*1000, '30m': 30*60*1000, '1h': 60*60*1000, '3h': 3*60*60*1000 };
  let currentRange = '5m';     // por defecto
  let isLiveMode   = true;     // autoscroll activo

  // Para nearestValue del tooltip que ya tienes
  let activeAxisIndex = null;

  // DOM
  const stationSelector  = $('#station-selector');
  const loadButton       = $('#load-sensors-btn');
  const valuesPanel      = $('#values-panel');
  const chipsWrap        = $('#range-chips');
  const liveIndicator    = $('#live-indicator');
  const backToLiveBtn    = $('#back-to-live');

  const chartDom         = document.getElementById('unified-chart');
  const unifiedChart     = echarts.init(chartDom);

  // ============================
  // MQTT
  // ============================
  initMQTTClient();
  stationSelector.on('change', () => loadButton.prop('disabled', !stationSelector.val()));
  loadButton.prop('disabled', !stationSelector.val());
  loadButton.on('click', () => {
    const stationId = stationSelector.val();
    if (stationId) fetchAndRenderUnifiedChart(stationId);
  });

  function initMQTTClient() {
    const clientId = "auralis_dashboard_" + Math.random().toString(16).substr(2, 8);
    try {
      mqttClient = new Paho.MQTT.Client("{{ mqtt_broker_ip }}", Number("{{ mqtt_broker_port }}"), "/", clientId);
      mqttClient.onConnectionLost = onConnectionLost;
      mqttClient.onMessageArrived = onMessageArrived;
      mqttClient.connect({
        onSuccess: () => console.log("MQTT Conectado"),
        onFailure: (e) => console.error("Conexión MQTT fallida:", e),
        useSSL: false, keepAliveInterval: 60
      });
    } catch (e) { console.error("Error creando cliente MQTT:", e); }
  }
  function onConnectionLost(resp) {
    if (resp.errorCode !== 0) {
      console.log("Conexión MQTT perdida:", resp.errorMessage);
      setTimeout(initMQTTClient, 5000);
    }
  }
  function subscribeToTopic(topic) {
    if (mqttClient && mqttClient.isConnected()) {
      mqttClient.subscribe(topic);
      currentSubscriptions.push(topic);
    }
  }
  function unsubscribeFromAllTopics() {
    if (mqttClient && mqttClient.isConnected()) {
      currentSubscriptions.forEach(t => mqttClient.unsubscribe(t));
    }
    currentSubscriptions = [];
  }

  // ============================
  // CARGA ESTACIÓN + HISTÓRICO
  // ============================
  function fetchAndRenderUnifiedChart(stationId) {
    unsubscribeFromAllTopics();

    // reset
    currentStationId = stationId;
    sensorMetadata = {}; sensorIndexById = {}; seriesBuffers = {};
    currentSensorIds = []; activeAxisIndex = null;
    unifiedChart.clear(); valuesPanel.empty();
    isLiveMode = true;
    setLiveUI(true);

    $.getJSON(`/api/stations/${stationId}/sensors/`, function (response) {
      if (!response.sensors || response.sensors.length === 0) return;

      currentStationName = response.station_name;
      $('#chart-panel-title').text(`Monitor en Tiempo Real - ${currentStationName}`);

      currentSensorIds = response.sensors.map(s => s.id);
      response.sensors.forEach((s, i) => {
        sensorMetadata[s.id] = s;
        sensorIndexById[s.id] = i;
        seriesBuffers[s.id] = [];
        // tarjetas
        valuesPanel.append(`
          <div class="live-card" id="live-card-${s.id}">
            <span class="name">${s.name}</span>
            <span><span class="val" id="value-display-${s.id}">--</span>
            <span class="unit">${s.unit || ''}</span></span>
          </div>`);
      });

      // Construir chart y setear opción base
      const option = buildUnifiedChartOption(response.sensors);
      unifiedChart.setOption(option, true);

      // Detectar grilla activa para tooltip mixto (si lo estás usando)
      unifiedChart.off('updateAxisPointer');
      unifiedChart.on('updateAxisPointer', function (e) {
        if (e.axesInfo && e.axesInfo.length) activeAxisIndex = e.axesInfo[0].axisIndex;
      });

      // Eventos para pausar/reanudar vivo según el slider
      unifiedChart.off('dataZoom');
      unifiedChart.on('dataZoom', function(){
        // tomamos el slider (el segundo dataZoom que es "slider")
        const opt = unifiedChart.getOption();
        const dz = (opt.dataZoom && opt.dataZoom.length > 1) ? opt.dataZoom[1] : null;
        if (!dz) return;
        // Si el extremo derecho está “casi” al 100%, consideramos vivo.
        const atRight = (typeof dz.end === 'number') ? (dz.end > 99) : true;
        setLiveUI(atRight);
        isLiveMode = atRight;
      });

      // Suscripciones MQTT
      response.sensors.forEach(sensor => {
        const topic = `${currentStationName}/${sensor.name}/`;
        subscribeToTopic(topic);
      });

      // Cargar histórico PARA EL RANGO ACTUAL (5m por defecto)
      requestHistory(currentRange);

      // Chips
      initRangeChips();

      // Resize
      setTimeout(() => unifiedChart.resize(), 0);
      $(window).off('resize._auralis').on('resize._auralis', () => unifiedChart.resize());
    });
  }

  function initRangeChips(){
    chipsWrap.find('.chip').removeClass('active');
    chipsWrap.find(`[data-range="${currentRange}"]`).addClass('active');

    chipsWrap.off('click', '.chip').on('click', '.chip', function(){
      const range = $(this).data('range');
      if (range === currentRange) return;
      currentRange = range;
      chipsWrap.find('.chip').removeClass('active');
      $(this).addClass('active');
      isLiveMode = true;
      setLiveUI(true);
      requestHistory(currentRange);
    });

    backToLiveBtn.off('click').on('click', function(){
      isLiveMode = true;
      setLiveUI(true);
      // reencuadrar a la derecha
      applyWindowToDataZoom(Date.now());
    });
  }

  function setLiveUI(on){
    if (on){
      liveIndicator.addClass('on').text('En vivo');
      backToLiveBtn.hide();
    } else {
      liveIndicator.removeClass('on').text('En pausa');
      backToLiveBtn.show();
    }
  }

  function requestHistory(range){
    if (!currentStationId) return;
    $.getJSON(`/api/stations/${currentStationId}/history?timescale=${encodeURIComponent(range)}`, function(history){
      // Vaciar buffers y rellenar con histórico
      for (const sid of currentSensorIds){
        seriesBuffers[sid] = [];
        const arr = history[sid] || [];
        for (const [tsISO, val] of arr){
          seriesBuffers[sid].push([ new Date(tsISO), Number(val) ]);
        }
      }
      // Poner datos en el chart
      const seriesUpdates = currentSensorIds.map(sid => ({ id:String(sid), data: seriesBuffers[sid] }));
      unifiedChart.setOption({ series: seriesUpdates }, false, true);

      // Encajar ventana a “ahora - rango .. ahora”
      applyWindowToDataZoom(Date.now());
    });
  }

  function applyWindowToDataZoom(nowMs){
    const endV = new Date(nowMs);
    const startV = new Date(nowMs - RANGE_MS[currentRange]);
    // actualiza ambos dataZoom (inside + slider)
    const xIdx = currentSensorIds.map((_, i) => i);
    unifiedChart.setOption({
      dataZoom: [
        { type:'inside', xAxisIndex:xIdx, startValue: startV, endValue: endV },
        { type:'slider', xAxisIndex:xIdx, startValue: startV, endValue: endV, bottom:2 }
      ]
    });
  }

  // ============================
  // OPCIÓN ECHARTS (igual base)
  // ============================
function buildUnifiedChartOption(sensors) {
  const n = sensors.length;
  const leftMarginPct = 9, rightMarginPct = 3;
  const topMargin = 6, bottomMargin = 12, gap = 2;
  const usable = 100 - topMargin - bottomMargin - (gap * (n - 1));
  const eachH = usable / n;

  const grids = [], xAxes = [], yAxes = [], series = [], graphics = [];
  const colorPalette = ['#5470C6','#91CC75','#FAC858','#EE6666','#73C0DE','#3BA272','#FC8452','#9A60B4','#EA7CCC'];

  sensors.forEach((s, i) => {
    const top = topMargin + i * (eachH + gap);
    grids.push({ top: `${top}%`, height: `${eachH}%`, left: `${leftMarginPct}%`, right: `${rightMarginPct}%` });
    xAxes.push({
      type: 'time', gridIndex: i, axisPointer: { show: true, snap: true },
      axisLabel: { show: i === n - 1, hideOverlap: true },
      axisLine:  { show: i === n - 1 }, axisTick: { show: i === n - 1 }, splitLine: { show: i === n - 1 }
    });
    yAxes.push({
      type: 'value', gridIndex: i, splitNumber: 3,
      min: isFinite(s.min_value) ? s.min_value : null,
      max: isFinite(s.max_value) ? s.max_value : null,
      axisLabel: {
        formatter: (v) => Math.abs(v) >= 1000 ? (v/1000).toFixed(1).replace(/\.0$/,'')+'k' : v
      }
    });
    series.push({
      name: s.name, id: String(s.id), type: 'line', showSymbol: false,
      xAxisIndex: i, yAxisIndex: i, data: [],
      lineStyle: { width: 2, color: colorPalette[i % colorPalette.length] },
      itemStyle: { color: colorPalette[i % colorPalette.length] }
    });
    graphics.push({
      type:'text', left:`${leftMarginPct + 1}%`, top:`${top + 1}%`,
      style:{ text:s.name, fontSize:12, fill:'#495057', backgroundColor:'rgba(255,255,255,0.6)', padding:[2,4] },
      silent:true
    });
  });

  const xIdx = sensors.map((_, i) => i);
  const dataZoom = [
    { type:'inside', xAxisIndex:xIdx },
    { type:'slider', xAxisIndex:xIdx, bottom:2 }
  ];

  // ===== Tooltip UNIFICADO (toma todos los sensores) =====
  const tooltip = {
    trigger:'axis',
    axisPointer:{ type:'cross', link:[{ xAxisIndex:'all' }], snap:true },
    confine:true,
    formatter: function(params){
      if(!params || !params.length) return '';
      // Timestamp objetivo (del eje)
      const tsAny = params[0].axisValue ?? params[0].value?.[0];
      const targetMs = (tsAny instanceof Date) ? tsAny.getTime() : new Date(tsAny).getTime();
      const d = new Date(targetMs);
      const dd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;

      // Serie "destacada": la que estás sobrevolando
      const highlightedName = params[0].seriesName;

      let html = `<div style="min-width:260px">
                    <div style="font-weight:700;margin-bottom:6px">${dd}</div>`;

      // 1) Línea grande para la serie destacada
      const highlighted = Object.values(sensorMetadata).find(s => s.name === highlightedName);
      if (highlighted) {
        const sid = highlighted.id;
        const nearest = nearestValue(seriesBuffers[sid], targetMs);
        const unit = highlighted.unit || '';
        const color = colorPalette[(sensorIndexById[sid] ?? 0) % colorPalette.length];
        const valText = (nearest.value == null) ? '--' : Number(nearest.value).toFixed(2);
        html += `<div style="display:flex;justify-content:space-between;gap:12px;align-items:baseline;margin-bottom:6px;">
                   <span style="display:flex;align-items:center;gap:6px;">
                     <span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color}"></span>
                     <span style="font-weight:600">${highlighted.name}</span>
                   </span>
                   <span style="font-weight:700;font-size:16px;">${valText} ${unit}</span>
                 </div>`;
      }

      // 2) Resto de sensores (pequeño)
      currentSensorIds.forEach((sid) => {
        const s = sensorMetadata[sid];
        if (!s || s.name === highlightedName) return;
        const nearest = nearestValue(seriesBuffers[sid], targetMs);
        const unit  = s.unit || '';
        const color = colorPalette[(sensorIndexById[sid] ?? 0) % colorPalette.length];
        const valText = (nearest.value == null) ? '--' : Number(nearest.value).toFixed(2);
        html += `<div style="display:flex;justify-content:space-between;gap:12px;">
                   <span style="display:flex;align-items:center;gap:6px;">
                     <span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color}"></span>
                     ${s.name}
                   </span>
                   <span style="font-weight:600">${valText} ${unit}</span>
                 </div>`;
      });

      html += `</div>`;
      return html;
    }
  };

  return { animation:false, grid:grids, xAxis:xAxes, yAxis:yAxes, series, dataZoom, tooltip, graphic:graphics };
}


  function findSensorByName(name) {
    const s = Object.values(sensorMetadata).find(x => x.name === name);
    return s || null;
  }

  // ============================
  // MQTT → actualizar + ventana móvil
  // ============================
  function onMessageArrived(message) {
    const topic = message.destinationName;  // "Station/Sensor/"
    const payload = message.payloadString;

    const parts = topic.slice(0, -1).split('/');
    if (parts.length < 2) return;
    if (parts[0] !== currentStationName) return;

    const sensorName = parts[1];
    const sensor = Object.values(sensorMetadata).find(s => s.name === sensorName);
    if (!sensor) return;

    const val = parseFloat(payload);
    if (Number.isNaN(val)) return;

    updateChartData(sensor.id, val);
  }

  function updateChartData(sensorId, value) {
    const now = new Date();

    // Tarjeta (derecha)
    $('#value-display-' + sensorId).text(Number(value).toFixed(2));

    // Buffer (siempre guardamos crudo) y purga por rango
    const buf = seriesBuffers[sensorId];
    buf.push([now, value]);

    // Purga en función del rango actual (solo si estamos en "vivo")
    if (isLiveMode) {
      const minTime = now.getTime() - RANGE_MS[currentRange];
      while (buf.length && buf[0][0].getTime() < minTime) buf.shift();
    }

    // Actualizar serie
    unifiedChart.setOption({ series: [{ id:String(sensorId), data: buf }] }, false, true);

    // Si estamos en vivo, movemos la ventana al final (autoscroll)
    if (isLiveMode) {
      applyWindowToDataZoom(now.getTime());
    }
  }

  // Busca el punto más cercano en el buffer [ [Date, value], ... ] al timestamp targetMs
function nearestValue(buf, targetMs){
  const n = buf ? buf.length : 0;
  if (!n) return { value: null, time: null };
  // binaria en tiempos crecientes
  let lo = 0, hi = n - 1;
  while (lo < hi) {
    const mid = (lo + hi) >> 1;
    const midTs = buf[mid][0].getTime();
    if (midTs < targetMs) lo = mid + 1;
    else hi = mid;
  }
  let idx = lo;
  if (idx > 0) {
    const t0 = buf[idx-1][0].getTime(), t1 = buf[idx][0].getTime();
    if (Math.abs(targetMs - t0) <= Math.abs(targetMs - t1)) idx = idx - 1;
  }
  return { value: buf[idx][1], time: buf[idx][0] };
}

});
</script>
{% endblock %}


